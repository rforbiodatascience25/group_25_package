---
title: "Guide to bio.mol.central (vignette)"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{bio-mol-central}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

link to the group´s GitHub: ***PUT AFTER***

### Introduction to the package and its functions

The `bio.mol.central` package relates to the **Central Dogma of Molecular Biology** and presents five simple, and illustrative, functions. Together, these functions simulate the flow of genetic information from **DNA → RNA → Protein**, while utilizing visualizations and string manipulation.

The vignette demonstrates how each function works (individually and in sequence) to represent the biological processes of replication, transcription, and translation.

#### Function 1: `random_seq_dna()`

This function simulates the creation of a random DNA sequence of specified length.

```{r}
random_seq_dna <- function(dna_size){
  dna_seq_generator <- sample(c("A", "T", "G", "C"), size = dna_size, replace = TRUE)
  concat_dna_seq <- paste0(dna_seq_generator, collapse = "")
  return(concat_dna_seq)
  }
```

Example:

```{r}
dna <- random_seq_dna(30)
dna
```

#### Function 2: `dna_to_rna()`

This function converts a DNA sequence into RNA by replacing all **T** with **U**.

```{r}
dna_to_rna <- function(dna_sequence) {
  rna_sequence <- gsub("T", "U", dna_sequence)
  return(rna_sequence)
}
```

Example:

```{r}
rna <- dna_to_rna(dna)
rna
```

#### Function 3: `codonInSeq()`

Splits an RNA sequence into codons, which are triplets of nucleotides that encode into one amino acid.

```{r}
codoInSeq <- function(sequence, start = 1){
  lengthSeq <- nchar(sequence)
  codons <- substring(sequence,
                      first = seq(from = start, to = lengthSeq-3+1, by = 3),
                      last = seq(from = 3+start-1, to = lengthSeq, by = 3))
  return(codons)
}
```

Example:

```{r}
codons <- codoInSeq(rna)
codons
```

#### Function 4: `codons_to_proteins_4()`

Translates RNA codons into an amino acid sequence using a predefined codon table. Assumes that the codon table (`codo)` is defined in your package environment.

```{r}
codons_to_proteins <- function(codons) {
  protein_sequence <- paste0(codo[codons], collapse = "")
  return(protein_sequence)
}
```

Example:

```{r}
protein <- codons_to_proteins(codons)
protein
```

#### Function 5: `plot_count_aa()`

This function visualizes and plots the amino acid composition of a protein sequence.

It uses stringr for character handling and ggplot2 for visualization.

```{r}
plot_count_aa <- function(sequence_aa){
  unique_aa <- sequence_aa |>
    stringr::str_split(pattern = stringr::boundary("character"), simplify = TRUE) |>
    as.character() |>
    unique()

  counts <- sapply(unique_aa, function(amino_acid) stringr::str_count(string = sequence_aa, pattern =  amino_acid)) |>
    as.data.frame()

  colnames(counts) <- c("Counts")
  counts[["Amino_Acids"]] <- rownames(counts)

  plot <- counts |>
    ggplot2::ggplot(ggplot2::aes(x = Amino_Acids, y = Counts, fill = Amino_Acids)) +
    ggplot2::geom_col() +
    ggplot2::theme_bw() +
    ggplot2::theme(legend.position = "none")

  return(plot)
}
```

Example:

```{r}
plot_count_aa(protein)
```

#### Using functions together

Here’s how the five functions work in sequence to model the central dogma:

```{r}
dna <- random_seq_dna(60)
rna <- dna_to_rna(dna)
codons <- codoInSeq(rna)
protein <- codons_to_protein_4(codons)
plot_count_aa(protein)
```

This pipeline shows the transformation from DNA → RNA → Protein → Visualization.

### Discussion

#### Dependencies of the package (***TASK 3 THINGS..... IMPROVE THIS PART!!!!!!)***

Dependencies include the packages `stringr` and `ggplot2`. Their usage is in function 5 for character handling and visualization.

***RESPOND TO THIS: how you added the two packages as dependencies***

Limiting and minimizing dependencies is a good practice because:

-   Dependencies increase the risk of version conflits

-   Installation time and CRAN checks grow with each added package

However, they also ensure that all functions and features run as expected while sharing and collaborating the package with others. And in this particular case, using packages like `ggplot2` is justified because visualization is central to the function's (and package's) purpose.

Import styles (***NOT SUREEE***):

-   `@importFrom package function` brings only selected functions into the namespace.

-   `package::function()` calls are explicit and safest for occasional use.

#### **Future work and Use cases**

Potential extensions include:

-   Adding GC-content analysis
-   Reading and analyzing real DNA sequences from FASTA files
-   Adding mutation analysis by comparing real and expected (**SEE IF THIS MAKES SENSE FOR YOU GUYS**)

Use cases:

-   Teaching and visualizing molecular biology basics
-   Demonstrating coding of biological processes
-   Visualizing sequence variation

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(bio.mol.central)
```
